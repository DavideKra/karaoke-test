<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>DavideKra — Album 3D</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik+Dirt&family=Inter:wght@400;700&display=swap" rel="stylesheet">

<style>
*{box-sizing:border-box}
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#000;
  font-family:Inter, system-ui, sans-serif;
  color:#fff;
}

/* ===== STAGE ===== */
#stage{
  position:fixed;
  inset:0;
  perspective:1400px;
  overflow:hidden;
}
#world{
  position:absolute;
  inset:0;
  transform-style:preserve-3d;
}

/* ===== SCENE ===== */
.scene{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  transform-style:preserve-3d;
  transition:opacity .25s ease;
  background-repeat:no-repeat;
  background-position:center;
  background-size:contain;
  will-change: transform, opacity;
}

/* scene overlay scuro */
.scene::before{
  content:"";
  position:absolute; inset:0;
  background:linear-gradient(to bottom, rgba(0,0,0,.45), rgba(0,0,0,.90));
  pointer-events:none;
}

/* contenuto sopra overlay */
.scene > *{ position:relative; z-index:2; }

/* ===== META ===== */
.meta{
  text-align:center;
  transition:opacity .35s ease;
  pointer-events:none;
  max-width:86vw;
}

.meta h1{
  margin:0;
  font-size:clamp(34px,6vw,68px);
  line-height:1.05;
  text-shadow:0 12px 44px rgba(0,0,0,.95);
}
.meta .artist{
  margin-top:10px;
  opacity:.7;
  text-shadow:0 10px 36px rgba(0,0,0,.9);
}

/* quando una scena è in play, nascondi meta */
.scene.is-playing .meta{ opacity:0; }

/* ===== KARAOKE ===== */
#karaoke{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  z-index:15;
}
#line{
  font-family:'Rubik Dirt', cursive;
  font-size:clamp(30px,5vw,58px);
  max-width:1100px;
  text-align:center;
  line-height:1.25;
  text-shadow:0 12px 44px rgba(0,0,0,.95);
  opacity:0;
  transition:opacity .22s ease;
}

/* ===== PLAYER ===== */
#audio{display:none}

#controls{
  position:fixed;
  bottom:26px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:24px;
  font-size:13px;
  opacity:.85;
  z-index:20;
  user-select:none;
}
#controls button{
  background:none;
  border:none;
  color:inherit;
  cursor:pointer;
  font-family:inherit;
}
#controls button:hover{ text-decoration:underline }

/* ===== BREATH (solo sulla scena attiva in play) ===== */
@keyframes bgPump{
  0%   { transform:translateZ(var(--rz, 0px)) scale(var(--scale, 1)); }
  50%  { transform:translateZ(var(--rz, 0px)) scale(calc(var(--scale, 1) * 1.18)); }
  100% { transform:translateZ(var(--rz, 0px)) scale(var(--scale, 1)); }
}

/* attiva respiro (la durata la puoi tweakare) */
.scene.breathing{
  animation:bgPump 1.15s linear infinite;
}
</style>
</head>

<body>

<div id="stage">
  <div id="world"></div>
</div>

<div id="karaoke"><div id="line"></div></div>

<audio id="audio" preload="metadata" crossorigin="anonymous"></audio>

<div id="controls">
  <button id="back">−10s</button>
  <button id="play">play</button>
  <button id="forward">+10s</button>
</div>

<script>
/* =====================
   TRACKLIST (2 TRACCE)
   ===================== */
const tracks = [
  {
    title: "Sai tenere un segreto?",
    artist: "DavideKra",
    cover: "https://i.ibb.co/nsyZJK7W/Sai-Tenere-Un-Segreto.png",
    audio: "DavideKra - 02 - Sai Tenere Un Segreto.mp3",
    vtt:   "DavideKra - 02 - Sai Tenere Un Segreto.vtt",
    titleFont: "'Rubik Dirt', cursive"
  },
  {
    title: "2 Cose Insieme",
    artist: "DavideKra",
    cover: "https://i.ibb.co/yndKknVM/2-cose-insieme.png",
    audio: "DavideKra - 03 - 2 Cose Insieme.mp3",
    vtt:   "DavideKra - 03 - 2 Cose Insieme.vtt",
    titleFont: "Inter, system-ui, sans-serif" // standard
  }
];

/* =====================
   CREATE SCENES
   ===================== */
const SCENE_DEPTH = 1200;
const world = document.getElementById("world");

const scenes = tracks.map((t, i) => {
  const s = document.createElement("div");
  s.className = "scene";
  s.style.backgroundImage = `url("${t.cover}")`;

  s.innerHTML = `
    <div class="meta">
      <h1 style="font-family:${t.titleFont}">${t.title}</h1>
      <div class="artist">${t.artist}</div>
    </div>
  `;

  world.appendChild(s);
  return { el: s, z: -i * SCENE_DEPTH, track: t };
});

/* =====================
   CAMERA SCROLL
   ===================== */
let cameraZ = 0;
let activeIndex = 0;

const MAX_Z = SCENE_DEPTH * (tracks.length - 1);
const SPEED = 0.9;

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function computeActiveIndex(){
  let bestI = 0;
  let bestD = Infinity;
  for (let i=0;i<scenes.length;i++){
    const rz = scenes[i].z + cameraZ;
    const d = Math.abs(rz);
    if (d < bestD){ bestD = d; bestI = i; }
  }
  return bestI;
}

/* =====================
   AUDIO + KARAOKE
   ===================== */
const audio = document.getElementById("audio");
const playBtn = document.getElementById("play");
const line = document.getElementById("line");

let currentTrackIndex = null; // traccia effettivamente caricata in audio
let trackEl = null;
let lastCue = null;

function clearKaraoke(){
  lastCue = null;
  line.style.opacity = 0;
  line.textContent = "";
  if (trackEl){
    try{ trackEl.remove(); }catch(e){}
    trackEl = null;
  }
}

function setBreathing(){
  // respiro SOLO se: audio in play && sei sulla scena della traccia che sta suonando
  scenes.forEach((s, i) => {
    const shouldBreathe = (!audio.paused) && (currentTrackIndex === i) && (activeIndex === i);
    s.el.classList.toggle("breathing", shouldBreathe);
  });
}

function loadTrack(index){
  const t = scenes[index].track;

  // se già caricata, non ricaricare
  if (currentTrackIndex === index && audio.src) return;

  clearKaraoke();

  currentTrackIndex = index;
  audio.src = t.audio;

  // track vtt
  trackEl = document.createElement("track");
  trackEl.kind = "subtitles";
  trackEl.srclang = "it";
  trackEl.label = "lyrics";
  trackEl.src = t.vtt;
  trackEl.default = true;
  audio.appendChild(trackEl);

  trackEl.addEventListener("load", () => {
    const tt = trackEl.track;
    tt.mode = "hidden";

    const refresh = () => {
      const a = tt.activeCues;
      if (!a || !a.length){
        line.style.opacity = 0;
        return;
      }
      const cue = a[0];
      if (cue === lastCue) return;
      lastCue = cue;

      line.style.opacity = 0;
      setTimeout(() => {
        line.textContent = cue.text;
        line.style.opacity = 1;
      }, 160);
    };

    tt.addEventListener("cuechange", refresh);
    audio.addEventListener("timeupdate", refresh);
  });
}

function updatePlayingMeta(){
  // nascondi meta SOLO sulla scena della traccia che sta suonando
  scenes.forEach((s, i) => {
    const isPlayingThis = (!audio.paused) && (currentTrackIndex === i);
    s.el.classList.toggle("is-playing", isPlayingThis);
  });
}

audio.addEventListener("play", () => { updatePlayingMeta(); setBreathing(); });
audio.addEventListener("pause", () => { updatePlayingMeta(); setBreathing(); });
audio.addEventListener("ended", () => {
  playBtn.textContent = "play";
  updatePlayingMeta();
  clearKaraoke();
  setBreathing();
});

/* =====================
   UPDATE SCENES (render)
   ===================== */
function updateScenes(){
  scenes.forEach((s) => {
    const rz = s.z + cameraZ;
    const dist = Math.abs(rz);

    const t = clamp(1 - (dist / SCENE_DEPTH), 0, 1);
    const scale = 0.72 + t * 0.28;
    const opacity = t;

    // set CSS vars per far “respirare” mantenendo la profondità
    s.el.style.setProperty("--rz", `${rz}px`);
    s.el.style.setProperty("--scale", `${scale}`);

    // se non sta respirando, applica transform normale
    if (!s.el.classList.contains("breathing")) {
      s.el.style.transform = `translateZ(${rz}px) scale(${scale})`;
    }

    s.el.style.opacity = opacity.toFixed(3);
  });

  const idx = computeActiveIndex();
  activeIndex = idx;

  // aggiorna respiro (dipende dalla scena attiva)
  setBreathing();
}

window.addEventListener("wheel", (e) => {
  e.preventDefault();
  cameraZ = clamp(cameraZ + e.deltaY * SPEED, 0, MAX_Z);
  updateScenes();
}, { passive:false });

/* =====================
   PLAYER ACTIONS
   ===================== */
playBtn.addEventListener("click", async () => {
  const t = scenes[activeIndex].track;

  // se sei su una scena senza audio (in futuro)
  if (!t.audio || !t.vtt) return;

  // SE l'audio è fermo: avvia la traccia della scena attiva
  if (audio.paused){
    // carica sempre la traccia della scena attiva prima di play
    loadTrack(activeIndex);
    await audio.play();
    playBtn.textContent = "pause";
    updatePlayingMeta();
    setBreathing();
    return;
  }

  // SE l'audio sta suonando:
  // - se premendo play sulla STESSA scena -> mette in pausa
  // - se premendo play su scena DIVERSA -> switcha traccia e continua
  if (currentTrackIndex === activeIndex){
    audio.pause();
    playBtn.textContent = "play";
    updatePlayingMeta();
    clearKaraoke();
    setBreathing();
  } else {
    // switch di traccia senza fermare la “sessione”
    loadTrack(activeIndex);
    await audio.play();
    playBtn.textContent = "pause";
    updatePlayingMeta();
    setBreathing();
  }
});

document.getElementById("back").addEventListener("click", () => {
  audio.currentTime = Math.max(0, audio.currentTime - 10);
});
document.getElementById("forward").addEventListener("click", () => {
  audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 10);
});

/* init */
updateScenes();
</script>

</body>
</html>
