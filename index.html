<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Davide*Kra — Album 3D</title>

<link href="https://fonts.googleapis.com/css2?family=Rubik+Dirt&family=Roboto:wght@300;400;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet" />

<style>
*{box-sizing:border-box}
html,body{margin:0;height:100%;overflow:hidden;background:#000;color:#fff}
:root{
  --hudBg: rgba(0,0,0,.30);
  --hudBd: rgba(255,255,255,.12);
  --hudTx: rgba(255,255,255,.88);
  --hudTx2: rgba(255,255,255,.72);
}

/* ===== FX CANVAS (overlay soft) ===== */
#fx{
  position:fixed; inset:0;
  z-index:12; /* sopra scene, sotto lyrics/HUD */
  pointer-events:none;
  mix-blend-mode: screen;
  opacity:.55;
}

/* ===== STAGE ===== */
#stage{
  position:fixed; inset:0;
  perspective:1700px;
  overflow:hidden;
  z-index:10;
}
#world{position:absolute; inset:0; transform-style:preserve-3d; will-change:transform;}

/* micro-thump */
@keyframes thump {
  0%   { transform: translateZ(0) translateX(0) scale(1); }
  35%  { transform: translateZ(0) translateX(-1.5px) scale(1.012); }
  70%  { transform: translateZ(0) translateX(1.0px) scale(0.998); }
  100% { transform: translateZ(0) translateX(0) scale(1); }
}
#world.thump{ animation: thump 240ms ease-out 1; }

/* ===== SCENE ===== */
.scene{
  position:absolute; inset:0;
  display:flex; align-items:center; justify-content:center;
  transform-style:preserve-3d;
  will-change:transform,opacity;
  opacity:0;
}

/* cover layer */
.scene .cover{
  position:absolute; inset:0;
  background-image: var(--cover-url);
  background-repeat:no-repeat;
  background-position:center;
  background-size:contain;
  transform: translateZ(0);
}

/* overlay for readability */
.scene::before{
  content:"";
  position:absolute; inset:0;
  background:linear-gradient(to bottom, rgba(0,0,0,.42), rgba(0,0,0,.90));
  pointer-events:none;
  z-index:2;
}

/* Reflection "floor" (compatibile) */
.scene .reflect{
  position:absolute;
  left:50%;
  top:52%;
  width:min(88vw, 980px);
  height:min(44vh, 520px);
  transform: translateX(-50%) translateY(18vh);
  background-image: var(--cover-url);
  background-repeat:no-repeat;
  background-position:center top;
  background-size:contain;
  opacity:.18;
  filter: blur(1.4px) saturate(1.05);
  transform-origin: top;
  transform: translateX(-50%) translateY(18vh) scaleY(-1);
  mask-image: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
  -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
  z-index:1;
  pointer-events:none;
}

/* content above */
.scene > *{position:relative; z-index:3}

/* ===== META center ===== */
.meta{
  text-align:center;
  pointer-events:none;
  max-width:86vw;
  transition:opacity .35s ease, transform .35s ease, filter .35s ease;
}
.meta .title{
  margin:0;
  font-size:clamp(34px,6vw,68px);
  line-height:1.05;
  text-shadow:0 12px 44px rgba(0,0,0,.95);
}
.meta .artist{
  margin-top:10px;
  opacity:.72;
  text-shadow:0 10px 36px rgba(0,0,0,.9);
}

/* meta sparisce SOLO sulla scena della traccia che sta suonando */
.scene.is-playing .meta{
  opacity:0;
  transform:translateY(-6px);
  filter:blur(.6px);
}

/* ===== Left title (big) ===== */
#leftTitle{
  position:fixed;
  top:18px; left:18px;
  z-index:40;
  padding:12px 14px;
  border-radius:14px;
  background:var(--hudBg);
  border:1px solid var(--hudBd);
  backdrop-filter: blur(8px);
  max-width:min(56vw, 740px);
  user-select:none;
}
#leftTitle .t{
  font-size:clamp(18px, 2.2vw, 26px);
  line-height:1.05;
  text-shadow:0 10px 28px rgba(0,0,0,.9);
}
#leftTitle .a{
  margin-top:6px;
  font: 12.5px/1.2 "Roboto", system-ui, sans-serif;
  color:var(--hudTx2);
}

/* per stile (titolo in alto a sinistra) */
body[data-active-style="thriller"] #leftTitle .t{ font-family:"Rubik Dirt", cursive; letter-spacing:.25px; }
body[data-active-style="normale"]  #leftTitle .t{ font-family:"Roboto", system-ui, sans-serif; font-weight:800; }
body[data-active-style="amore"]    #leftTitle .t{ font-family:"Playfair Display", serif; font-weight:800; }

/* ===== Right legend ===== */
#hud{
  position:fixed;
  top:18px; right:18px;
  z-index:40;
  font: 12.5px/1.25 "Roboto", system-ui, sans-serif;
  color:var(--hudTx);
  background:var(--hudBg);
  border:1px solid var(--hudBd);
  padding:12px 14px;
  border-radius:14px;
  backdrop-filter: blur(8px);
  user-select:none;
  max-width: min(40vw, 520px);
}
#hud .hash{font-weight:900; letter-spacing:.25px}
#hud .hint{margin-top:8px; font-size:12px; opacity:.82}

/* ===== Mini-map with always-visible titles ===== */
#minimap{
  position:fixed;
  right:18px;
  top:130px;
  z-index:40;
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:12px 12px;
  border-radius:14px;
  background:var(--hudBg);
  border:1px solid var(--hudBd);
  backdrop-filter: blur(8px);
  max-width:min(40vw, 520px);
}
.mm-item{
  display:flex;
  align-items:center;
  gap:10px;
  cursor:pointer;
  user-select:none;
}
.mm-dot{
  width:10px; height:10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.22);
  background:rgba(255,255,255,.14);
  flex:0 0 auto;
}
.mm-item:hover .mm-dot{background:rgba(255,255,255,.24)}
.mm-item.active .mm-dot{
  background:rgba(255,255,255,.95);
  border-color:rgba(255,255,255,.95);
}
.mm-item.playing .mm-dot{
  box-shadow:0 0 0 6px rgba(255,255,255,.10);
}
.mm-label{
  font: 12.5px/1.2 "Roboto", system-ui, sans-serif;
  color:rgba(255,255,255,.86);
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

/* ===== Karaoke ===== */
#karaoke{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  pointer-events:none;
  z-index:25;
  padding:40px;
}
#line{
  max-width:1100px;
  text-align:center;
  line-height:1.25;
  opacity:0;
  transition:opacity .18s ease, transform .32s ease, filter .32s ease;
  text-shadow:0 12px 44px rgba(0,0,0,.95);
  font-size:clamp(30px,5vw,58px);
}
/* Font testo per stile */
body[data-active-style="thriller"] #line{ font-family:"Rubik Dirt", cursive; }
body[data-active-style="normale"]  #line{ font-family:"Roboto", system-ui, sans-serif; font-weight:700; }
body[data-active-style="amore"]    #line{ font-family:"Roboto", system-ui, sans-serif; font-weight:700; }

/* Transitions */
.t-fade-in   { transform:none; filter:none; }
.t-pop       { transform:scale(1.08); filter:none; }
.t-slide-up  { transform:translateY(40px); filter:none; }
.t-slide-down{ transform:translateY(-40px); filter:none; }
.t-slide-left{ transform:translateX(60px); filter:none; }
.t-slide-right{transform:translateX(-60px); filter:none; }
.t-rotate    { transform:rotate(-3deg) scale(.98); filter:none; }
.t-blur      { transform:none; filter:blur(14px); }
.t-stretch   { transform:scaleY(.72); filter:none; }
.t-snap      { transform:scale(.92); filter:contrast(1.2); }
.t-jitter    { transform:translateX(-6px) rotate(.8deg); filter:none; }

/* ===== Player ===== */
#audioA,#audioB{display:none}
#playerTitle{
  position:fixed;
  bottom:56px;
  left:50%;
  transform:translateX(-50%);
  z-index:32;
  font: 12.5px/1.2 "Roboto", system-ui, sans-serif;
  color:rgba(255,255,255,.86);
  opacity:.9;
  user-select:none;
  text-shadow:0 10px 28px rgba(0,0,0,.9);
}
#controls{
  position:fixed;
  bottom:26px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  gap:24px;
  font: 13px/1.2 "Roboto", system-ui, sans-serif;
  opacity:.86;
  z-index:31;
  user-select:none;
}
#controls button{
  background:none;
  border:none;
  color:rgba(255,255,255,.85);
  cursor:pointer;
  padding:4px 6px;
}
#controls button:hover{ color:#fff; text-decoration:underline; }

/* ===== Breathing ===== */
@keyframes bgPump{
  0%   { transform:translateZ(var(--rz, 0px)) scale(var(--scale, 1)); }
  50%  { transform:translateZ(var(--rz, 0px)) scale(calc(var(--scale, 1) * var(--breatheScale, 1.12))); }
  100% { transform:translateZ(var(--rz, 0px)) scale(var(--scale, 1)); }
}
.scene.breathing{
  animation: bgPump var(--breatheDur, 1.2s) linear infinite;
}

@media (prefers-reduced-motion: reduce){
  .scene.breathing{ animation:none; }
  #line{ transition:none; }
  #fx{ display:none; }
}
</style>
</head>

<body data-active-style="normale">

<div id="leftTitle">
  <div class="t" id="leftT">—</div>
  <div class="a" id="leftA">—</div>
</div>

<div id="hud">
  <div class="hash" id="hash">#</div>
  <div class="hint">
    Scorri con la rotellina avanti e indietro per vedere le tracce.<br>
    Premi <b>Play</b> per far partire la canzone scelta.<br>
    Tieni premuto <b>Shift</b> e scorri per “scrubbare” il tempo della canzone.
  </div>
</div>

<div id="minimap" aria-label="Album map"></div>

<div id="stage"><div id="world"></div></div>
<canvas id="fx"></canvas>

<div id="karaoke"><div id="line"></div></div>

<audio id="audioA" preload="metadata" crossorigin="anonymous"></audio>
<audio id="audioB" preload="metadata" crossorigin="anonymous"></audio>

<div id="playerTitle">—</div>
<div id="controls">
  <button id="back">−10s</button>
  <button id="play">play</button>
  <button id="forward">+10s</button>
</div>

<script>
/* =========================
   TRACKS
   ========================= */
const tracks = [
  {
    artist:"Davide*Kra",
    title:"In Throw",
    bpm:90,
    style:"normale",
    cover:"https://i.ibb.co/9mtLF0JV/In-Throw.png",
    audio:"DavideKra - 01 - In Throw.mp3",
    vtt:"DavideKra - 01 - In Throw.vtt"
  },
  {
    artist:"Davide*Kra",
    title:"Sai Tenere Un Segreto?",
    bpm:126,
    style:"thriller",
    cover:"https://i.ibb.co/nsyZJK7W/Sai-Tenere-Un-Segreto.png",
    audio:"DavideKra - 02 - Sai Tenere Un Segreto.mp3",
    vtt:"DavideKra - 02 - Sai Tenere Un Segreto.vtt"
  },
  {
    artist:"Davide*Kra",
    title:"2 cose insieme",
    bpm:91,
    style:"normale",
    cover:"https://i.ibb.co/yndKknVM/2-cose-insieme.png",
    audio:"DavideKra - 03 - 2 Cose Insieme.mp3",
    vtt:"DavideKra - 03 - 2 Cose Insieme.vtt"
  }
];

const STYLE = {
  thriller: { transitions:["t-blur","t-rotate","t-jitter","t-snap","t-slide-up","t-slide-down","t-pop","t-stretch","t-fade-in"], breatheAmp:1.10 },
  normale:  { transitions:["t-fade-in","t-slide-up","t-slide-down","t-pop","t-slide-left","t-slide-right","t-snap"], breatheAmp:1.00 },
  amore:    { transitions:["t-fade-in","t-pop","t-slide-up","t-slide-right","t-slide-left","t-snap","t-stretch"], breatheAmp:0.95 }
};

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

function bpmToBreath(bpm, styleKey){
  const s = STYLE[styleKey] || STYLE.normale;
  let dur = 120 / Math.max(40, bpm);
  dur = clamp(dur, 0.70, 2.1);
  let amp = 1.06 + (bpm - 70) * 0.0015;
  amp = clamp(amp, 1.06, 1.22) * s.breatheAmp;
  amp = clamp(amp, 1.06, 1.30);
  return { dur, amp };
}
function pickTransition(styleKey){
  const set=(STYLE[styleKey]||STYLE.normale).transitions;
  return set[(Math.random()*set.length)|0];
}

function slugify(title){
  return (title||"")
    .normalize("NFD").replace(/[\u0300-\u036f]/g,"")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g,"-")
    .replace(/(^-|-$)/g,"");
}
function toHashTag(title){
  const s = slugify(title)
    .split("-")
    .filter(Boolean)
    .map(w=>w.charAt(0).toUpperCase()+w.slice(1))
    .join("");
  return "#"+(s||"Track");
}

/* =========================
   SCENES + DEPTH
   ========================= */
const stage = document.getElementById("stage");
const world = document.getElementById("world");
const SCENE_DEPTH = 2100;
const scenes = tracks.map((t,i)=>{
  const el=document.createElement("div");
  el.className="scene";
  el.dataset.style=t.style;
  el.style.setProperty("--cover-url", `url("${t.cover}")`);
  el.innerHTML=`
    <div class="reflect"></div>
    <div class="cover"></div>
    <div class="meta">
      <div class="title">${t.title}</div>
      <div class="artist">${t.artist}</div>
    </div>`;
  world.appendChild(el);
  return { el, z:-i*SCENE_DEPTH, track:t, index:i, slug: slugify(t.title) };
});
const MAX_Z = SCENE_DEPTH * (tracks.length-1);

/* =========================
   HUD
   ========================= */
const hashEl=document.getElementById("hash");
const playerTitle=document.getElementById("playerTitle");
const leftT=document.getElementById("leftT");
const leftA=document.getElementById("leftA");

function setActiveStyle(styleKey){ document.body.dataset.activeStyle = styleKey || "normale"; }

function updateHUD(){
  const t=scenes[activeIndex].track;
  hashEl.textContent = toHashTag(t.title);
  playerTitle.textContent = `${t.artist} — ${t.title}`;
  leftT.textContent = t.title;
  leftA.textContent = `${t.artist} • ${t.bpm} BPM • ${t.style}`;
}

/* =========================
   MINIMAP (titles always visible)
   ========================= */
const minimap=document.getElementById("minimap");
const mmItems = scenes.map((s,i)=>{
  const row=document.createElement("div");
  row.className="mm-item";
  row.innerHTML = `<div class="mm-dot"></div><div class="mm-label">${s.track.title}</div>`;
  row.addEventListener("click", ()=>{
    targetZ = clamp(i*SCENE_DEPTH, 0, MAX_Z);
    snapArmed = false; // già snap
  });
  minimap.appendChild(row);
  return row;
});

/* =========================
   CAMERA: inertia + snap + THUMP
   ========================= */
let cameraZ=0;
let targetZ=0;
let activeIndex=0;

const SPEED=0.95;
let snapTimer=null;
let snapArmed=false;
let lastSnappedIndex=null;

function computeActiveIndex(zVal){
  let bestI=0, bestD=Infinity;
  for(let i=0;i<scenes.length;i++){
    const rz = scenes[i].z + zVal;
    const d = Math.abs(rz);
    if(d<bestD){ bestD=d; bestI=i; }
  }
  return bestI;
}

function triggerThump(){
  world.classList.remove("thump");
  // reflow
  void world.offsetWidth;
  world.classList.add("thump");
  setTimeout(()=>world.classList.remove("thump"), 260);
}

function armSnap(){
  snapArmed = true;
  if(snapTimer) clearTimeout(snapTimer);
  snapTimer = setTimeout(()=>{
    if(!snapArmed) return;
    const nearest = Math.round(targetZ / SCENE_DEPTH) * SCENE_DEPTH;
    targetZ = clamp(nearest, 0, MAX_Z);
  }, 140);
}

/* =========================
   DEEP LINKING (History API)
   - on snap settle -> update hash
   - on load -> jump to hash
   ========================= */
function setHashForIndex(i){
  const slug = scenes[i]?.slug || "";
  if(!slug) return;
  history.replaceState(null, "", `#${slug}`);
}

function readHashIndex(){
  const h = (location.hash || "").replace("#","").trim().toLowerCase();
  if(!h) return null;
  const idx = scenes.findIndex(s => s.slug === h);
  return idx >= 0 ? idx : null;
}

/* =========================
   AUDIO ENGINE (crossfade) + lyrics slice
   ========================= */
const audioA=document.getElementById("audioA");
const audioB=document.getElementById("audioB");
const audios=[audioA,audioB];

let audioCtx=null, srcA=null, srcB=null, gA=null, gB=null;
let currentPlayer=0;
let playingIndex=null;

let vttSession=0;
let currentTrackEl=null;

const playBtn=document.getElementById("play");
const line=document.getElementById("line");

function ensureAudioGraph(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  srcA = audioCtx.createMediaElementSource(audioA);
  srcB = audioCtx.createMediaElementSource(audioB);
  gA = audioCtx.createGain();
  gB = audioCtx.createGain();
  gA.gain.value = 1;
  gB.gain.value = 0;
  srcA.connect(gA).connect(audioCtx.destination);
  srcB.connect(gB).connect(audioCtx.destination);
}
function getCurrentAudio(){ return audios[currentPlayer]; }
function getOtherAudio(){ return audios[1-currentPlayer]; }
function getCurrentGain(){ return currentPlayer===0 ? gA : gB; }
function getOtherGain(){ return currentPlayer===0 ? gB : gA; }

function clearKaraoke(){
  vttSession++;
  line.style.opacity=0;
  line.textContent="";
  if(currentTrackEl){
    try{ currentTrackEl.remove(); }catch(e){}
    currentTrackEl=null;
  }
}

function bindKaraokeTo(playerEl, trackObj){
  clearKaraoke();
  const mySession = vttSession;

  const tr=document.createElement("track");
  tr.kind="subtitles";
  tr.srclang="it";
  tr.label="lyrics";
  tr.src=trackObj.vtt;
  tr.default=true;
  playerEl.appendChild(tr);
  currentTrackEl = tr;

  tr.addEventListener("load", ()=>{
    if(mySession !== vttSession) return;
    const tt = tr.track;
    tt.mode="hidden";
    let lastCue=null;

    const refresh=()=>{
      if(mySession !== vttSession) return;

      // testo SOLO se sono nello "spicchio" della traccia in play
      if(playingIndex === null || activeIndex !== playingIndex) { line.style.opacity=0; return; }
      if(getCurrentAudio().paused) { line.style.opacity=0; return; }

      const a = tt.activeCues;
      if(!a || !a.length){ line.style.opacity=0; return; }

      const cue=a[0];
      if(cue===lastCue) return;
      lastCue=cue;

      const trClass = pickTransition(trackObj.style);
      line.className = trClass;
      line.style.opacity = 0;

      setTimeout(()=>{
        if(mySession !== vttSession) return;
        if(playingIndex === null || activeIndex !== playingIndex) { line.style.opacity=0; return; }
        if(getCurrentAudio().paused) { line.style.opacity=0; return; }
        line.textContent = cue.text;
        line.className = "t-fade-in";
        line.style.opacity = 1;
      }, 150);
    };

    tt.addEventListener("cuechange", refresh);
    playerEl.addEventListener("timeupdate", refresh);
    playerEl.addEventListener("seeked", ()=>{ lastCue=null; refresh(); });
    refresh();
  });
}

function updatePlayingUI(){
  const a = getCurrentAudio();
  playBtn.textContent = (playingIndex !== null && !a.paused) ? "pause" : "play";

  scenes.forEach((s,i)=>{
    s.el.classList.toggle("is-playing", (playingIndex===i && playingIndex!==null && !a.paused));
  });

  mmItems.forEach((row,i)=>{
    row.classList.toggle("active", i===activeIndex);
    row.classList.toggle("playing", (i===playingIndex && playingIndex!==null && !a.paused));
  });

  setBreathing();
}

function setBreathing(){
  const a = getCurrentAudio();
  scenes.forEach((s,i)=>{
    const should = (playingIndex===i) && (activeIndex===i) && (playingIndex!==null) && !a.paused;
    s.el.classList.toggle("breathing", should);
    if(should){
      const {dur, amp} = bpmToBreath(s.track.bpm, s.track.style);
      s.el.style.setProperty("--breatheDur", `${dur}s`);
      s.el.style.setProperty("--breatheScale", `${amp}`);
    }
  });
}

async function playOrToggle(){
  ensureAudioGraph();
  await audioCtx.resume();

  const wantIndex = activeIndex;
  const want = scenes[wantIndex].track;

  if(playingIndex === null){
    playingIndex = wantIndex;
    const a = getCurrentAudio();
    a.src = want.audio;
    a.load();
    setActiveStyle(want.style);
    bindKaraokeTo(a, want);
    await a.play();
    updatePlayingUI();
    return;
  }

  if(playingIndex === wantIndex){
    const a = getCurrentAudio();
    if(a.paused){
      await a.play();
    }else{
      a.pause();
      line.style.opacity=0;
    }
    updatePlayingUI();
    return;
  }

  await crossfadeTo(wantIndex);
}

async function crossfadeTo(nextIndex){
  const FADE = 1.15;

  const prevAudio = getCurrentAudio();
  const nextAudio = getOtherAudio();
  const prevGain = getCurrentGain();
  const nextGain = getOtherGain();

  const next = scenes[nextIndex].track;

  playingIndex = nextIndex;
  setActiveStyle(next.style);

  nextAudio.pause();
  nextAudio.currentTime = 0;
  nextAudio.src = next.audio;
  nextAudio.load();

  bindKaraokeTo(nextAudio, next);

  nextGain.gain.cancelScheduledValues(audioCtx.currentTime);
  prevGain.gain.cancelScheduledValues(audioCtx.currentTime);
  nextGain.gain.setValueAtTime(0, audioCtx.currentTime);

  await nextAudio.play();

  nextGain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + FADE);
  prevGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + FADE);

  setTimeout(()=>{
    try{
      prevAudio.pause();
      prevAudio.removeAttribute("src");
      prevAudio.load();
    }catch(e){}
  }, (FADE*1000)+60);

  currentPlayer = 1-currentPlayer;
  updatePlayingUI();
}

/* controls */
document.getElementById("play").addEventListener("click", playOrToggle);
document.getElementById("back").addEventListener("click", ()=>{
  const a = getCurrentAudio();
  a.currentTime = Math.max(0, (a.currentTime||0) - 10);
});
document.getElementById("forward").addEventListener("click", ()=>{
  const a = getCurrentAudio();
  a.currentTime = Math.min((a.duration||0), (a.currentTime||0) + 10);
});

/* =========================
   Shift+Scroll scrub
   ========================= */
function scrub(deltaY){
  if(playingIndex === null) return;
  const a = getCurrentAudio();
  if(!a || isNaN(a.currentTime)) return;
  const seconds = (deltaY / 100) * 2.0;
  a.currentTime = clamp(a.currentTime + seconds, 0, (a.duration||a.currentTime+10));
  if(activeIndex !== playingIndex) line.style.opacity=0;
}

window.addEventListener("wheel",(e)=>{
  e.preventDefault();
  if(e.shiftKey){
    scrub(e.deltaY);
    return;
  }
  targetZ = clamp(targetZ + e.deltaY * 0.95, 0, MAX_Z);
  armSnap();
},{passive:false});

/* =========================
   SCENE RENDER LOOP + snap settle hook
   ========================= */
function updateScenes(){
  activeIndex = computeActiveIndex(cameraZ);

  // scene transforms
  for(const s of scenes){
    const rz = s.z + cameraZ;
    const dist = Math.abs(rz);
    const t = clamp(1 - (dist/SCENE_DEPTH), 0, 1);
    const scale = 0.70 + t*0.30;
    const opacity = t;

    s.el.style.setProperty("--rz", `${rz}px`);
    s.el.style.setProperty("--scale", `${scale}`);

    if(!s.el.classList.contains("breathing")){
      s.el.style.transform = `translateZ(${rz}px) scale(${scale})`;
    }
    s.el.style.opacity = opacity.toFixed(3);
  }

  // slice lyrics rule
  if(playingIndex === null || activeIndex !== playingIndex || getCurrentAudio().paused){
    line.style.opacity = 0;
  }

  updateHUD();
  updatePlayingUI();

  // FX per stile basato su scena attiva
  fxSetMode(scenes[activeIndex].track.style);
}

/* snap settle detection */
let lastSettled = null;
function tick(){
  const diff = (targetZ - cameraZ);
  cameraZ += diff * 0.12;
  if(Math.abs(diff) < 0.35) cameraZ = targetZ;

  updateScenes();

  // quando "si ferma" nello snap, applica thump + deep link (una sola volta)
  const nowIndex = Math.round(cameraZ / SCENE_DEPTH);
  const settled = (Math.abs(targetZ-cameraZ) < 0.6) && (Math.abs((targetZ/SCENE_DEPTH)-Math.round(targetZ/SCENE_DEPTH)) < 0.001);

  if(settled){
    if(lastSettled !== nowIndex){
      lastSettled = nowIndex;
      triggerThump();
      setHashForIndex(nowIndex);
    }
  }

  requestAnimationFrame(tick);
}

/* deep link on load */
function jumpToHashIfAny(){
  const idx = readHashIndex();
  if(idx === null) return;
  targetZ = clamp(idx*SCENE_DEPTH, 0, MAX_Z);
  cameraZ = targetZ; // jump immediato (pulito)
  lastSettled = idx;
}

function setHashForIndex(i){
  const slug = scenes[i]?.slug || "";
  if(!slug) return;
  history.replaceState(null, "", `#${slug}`);
}
function readHashIndex(){
  const h = (location.hash || "").replace("#","").trim().toLowerCase();
  if(!h) return null;
  const idx = scenes.findIndex(s => s.slug === h);
  return idx >= 0 ? idx : null;
}

/* thump */
function triggerThump(){
  world.classList.remove("thump");
  void world.offsetWidth;
  world.classList.add("thump");
  setTimeout(()=>world.classList.remove("thump"), 260);
}

/* init */
targetZ = 0;
cameraZ = 0;
jumpToHashIfAny();
updateHUD();
updateScenes();
requestAnimationFrame(tick);

/* =========================
   FX CANVAS — per stile
   thriller: rain + static
   normale: dust
   amore: fireflies
   ========================= */
const fx = document.getElementById("fx");
const fxc = fx.getContext("2d", { alpha:true });

let fxW=0, fxH=0;
let fxMode="normale";
let fxModeWanted="normale";

function resizeFx(){
  fxW = fx.width = Math.floor(window.innerWidth * devicePixelRatio);
  fxH = fx.height = Math.floor(window.innerHeight * devicePixelRatio);
  fxc.setTransform(1,0,0,1,0,0);
}
window.addEventListener("resize", resizeFx);
resizeFx();

function fxSetMode(m){
  fxModeWanted = m || "normale";
}

const dust = Array.from({length:140}, ()=>mkParticle("dust"));
const fire = Array.from({length:110}, ()=>mkParticle("fire"));
const rain = Array.from({length:160}, ()=>mkParticle("rain"));

function mkParticle(kind){
  const r = Math.random();
  if(kind==="dust"){
    return {
      x: Math.random(), y: Math.random(),
      vx: (Math.random()*0.10 + 0.02) * (Math.random()<.5?-1:1),
      vy: -(Math.random()*0.06 + 0.01),
      s: 0.6 + Math.random()*1.8,
      a: 0.06 + Math.random()*0.10
    };
  }
  if(kind==="fire"){ // lucciole
    return {
      x: Math.random(), y: 1 + Math.random()*0.4,
      vx: (Math.random()*0.12 + 0.02) * (Math.random()<.5?-1:1),
      vy: -(Math.random()*0.18 + 0.06),
      s: 1.2 + Math.random()*2.6,
      a: 0.10 + Math.random()*0.14,
      w: 0.6 + Math.random()*1.6,
      ph: Math.random()*Math.PI*2
    };
  }
  // rain
  return {
    x: Math.random(), y: Math.random(),
    vx: 0.02 + Math.random()*0.03,
    vy: 0.70 + Math.random()*1.10,
    len: 0.018 + Math.random()*0.04,
    a: 0.05 + Math.random()*0.10
  };
}

function drawNoiseStatic(){
  // static leggero: pochi sample per performance
  const step = Math.max(6, Math.floor(10 * devicePixelRatio));
  const imgW = fxW, imgH = fxH;
  fxc.save();
  fxc.globalAlpha = 0.12;
  for(let y=0; y<imgH; y+=step){
    for(let x=0; x<imgW; x+=step){
      const v = (Math.random()*255)|0;
      fxc.fillStyle = `rgba(${v},${v},${v},0.22)`;
      fxc.fillRect(x,y,step,step);
    }
  }
  fxc.restore();
}

function fxLoop(){
  // smooth mode switch
  if(fxMode !== fxModeWanted) fxMode = fxModeWanted;

  fxc.clearRect(0,0,fxW,fxH);

  if(fxMode === "thriller"){
    // rain
    fxc.save();
    fxc.globalCompositeOperation = "screen";
    for(const p of rain){
      p.y += p.vy * 0.0045;
      p.x += p.vx * 0.0022;
      if(p.y > 1.05){ p.y = -0.05; p.x = Math.random(); }
      if(p.x > 1.05) p.x = -0.05;
      const x = p.x * fxW;
      const y = p.y * fxH;
      const x2 = x + p.vx * fxW * 0.02;
      const y2 = y + p.vy * fxH * 0.03;
      fxc.strokeStyle = `rgba(220,240,255,${p.a})`;
      fxc.lineWidth = Math.max(1, 1.2*devicePixelRatio);
      fxc.beginPath();
      fxc.moveTo(x,y);
      fxc.lineTo(x2,y2);
      fxc.stroke();
    }
    fxc.restore();

    // static tv
    drawNoiseStatic();
  }
  else if(fxMode === "amore"){
    // lucciole
    fxc.save();
    fxc.globalCompositeOperation = "screen";
    for(const p of fire){
      p.ph += 0.02 * p.w;
      p.x += p.vx * 0.0012 + Math.sin(p.ph)*0.0006;
      p.y += p.vy * 0.0012;
      if(p.y < -0.25){ p.y = 1.15; p.x = Math.random(); }
      if(p.x < -0.1) p.x = 1.1;
      if(p.x > 1.1) p.x = -0.1;

      const x = p.x * fxW;
      const y = p.y * fxH;
      const r = (p.s * devicePixelRatio) * (0.8 + 0.4*Math.sin(p.ph));
      const grd = fxc.createRadialGradient(x,y,0,x,y,r*6);
      grd.addColorStop(0, `rgba(255,230,160,${p.a})`);
      grd.addColorStop(1, `rgba(255,230,160,0)`);
      fxc.fillStyle = grd;
      fxc.beginPath();
      fxc.arc(x,y,r*6,0,Math.PI*2);
      fxc.fill();
    }
    fxc.restore();
  }
  else {
    // normale: dust
    fxc.save();
    fxc.globalCompositeOperation = "screen";
    for(const p of dust){
      p.x += p.vx * 0.0011;
      p.y += p.vy * 0.0010;
      if(p.y < -0.1){ p.y = 1.1; p.x = Math.random(); }
      if(p.x < -0.1) p.x = 1.1;
      if(p.x > 1.1) p.x = -0.1;

      const x = p.x * fxW;
      const y = p.y * fxH;
      fxc.fillStyle = `rgba(220,230,255,${p.a})`;
      fxc.beginPath();
      fxc.arc(x,y,Math.max(1, p.s*devicePixelRatio),0,Math.PI*2);
      fxc.fill();
    }
    fxc.restore();
  }

  requestAnimationFrame(fxLoop);
}
fxLoop();
</script>

</body>
</html>
